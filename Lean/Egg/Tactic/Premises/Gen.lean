import Egg.Core.Gen.Builtins
import Egg.Core.Gen.Tagged
import Egg.Core.Gen.TcProjs
import Egg.Core.Gen.TcSpecs
import Egg.Core.Gen.Explosion
import Egg.Core.Gen.NestedSplits
import Egg.Tactic.Premises.Parse
import Egg.Tactic.Trace
import Egg.Tactic.Tags
import Lean

open Lean hiding HashSet
open Meta Elab Tactic
open Std (HashSet)

-- TODO: Perform pruning during generation, not after.

namespace Egg.Premises.GenM

private inductive RewriteCategory where
  | tagged
  | basic
  | builtins
  | typeClass
  | explosion
  | splits

private def RewriteCategory.title : RewriteCategory → String
  | .tagged    => "Tagged"
  | .basic     => "Basic"
  | .builtins  => "Builtin"
  | .typeClass => "Type Class"
  | .explosion => "Explosion"
  | .splits    => "Split Nested"

private def RewriteCategory.isAutogenerated : RewriteCategory → Bool
  | .typeClass | .explosion | .splits => true
  | _                                 => false

private structure State where
  all       : Rewrites
  pruned    : Rewrites
  facts     : WithSyntax Facts
  tagged    : Rewrites
  basic     : Rewrites
  builtins  : Rewrites
  typeClass : Rewrites
  explosion : Rewrites
  splits    : Rewrites

instance : EmptyCollection State where
  emptyCollection := {
    all       := {}
    pruned    := {}
    facts     := {}
    tagged    := {}
    basic     := {}
    builtins  := {}
    typeClass := {}
    explosion := {}
    splits    := {}
  }

private def State.get (s : State) : RewriteCategory → Rewrites
  | .tagged    => s.tagged
  | .basic     => s.basic
  | .builtins  => s.builtins
  | .typeClass => s.typeClass
  | .explosion => s.explosion
  | .splits    => s.splits

private def State.set (s : State) : RewriteCategory → Rewrites → State
  | .tagged,    rws => { s with tagged    := rws }
  | .basic,     rws => { s with basic     := rws }
  | .builtins,  rws => { s with builtins  := rws }
  | .typeClass, rws => { s with typeClass := rws }
  | .explosion, rws => { s with explosion := rws }
  | .splits,    rws => { s with splits    := rws }

private abbrev _root_.Egg.Premises.GenM := StateT State TacticM

structure Result where
  all    : Rewrites
  pruned : Rewrites
  facts  : WithSyntax Facts

def run (m : GenM Unit) : TacticM Result := do
  let { all, pruned, facts, .. } ← Prod.snd <$> m.run ∅
  return { all, pruned, facts }

def all : GenM Rewrites :=
  return (← get).all

private def addAll (new : Rewrites) : GenM Unit := do
  modify fun s => { s with all := s.all ++ new }

def facts : GenM (WithSyntax Facts) :=
  return (← get).facts

private def addFacts (new : WithSyntax Facts) : GenM Unit := do
  modify fun s => { s with facts := s.facts ++ new }

private def addPruned (new : Rewrites) : GenM Unit := do
  modify fun s => { s with pruned := s.pruned ++ new }

def set (cat : RewriteCategory) (rws : Rewrites) : GenM Unit :=
  modify (·.set cat rws)

nonrec def get (cat : RewriteCategory) : GenM Rewrites :=
  return (← get).get cat

private def prune (rws : Rewrites) (stx? : Option (Array Syntax) := none) : GenM (Rewrites × Array Syntax) := do
  let mut keep := #[]
  let mut keepStx := #[]
  let mut pruned := #[]
  let contains (tgts : Rewrites) (rw : Rewrite) : MetaM Bool := do
    let lhsAbs ← abstractMVars rw.lhs
    let rhsAbs ← abstractMVars rw.rhs
    let conds  ← rw.conds.mapM (AbstractMVarsResult.expr <$> abstractMVars ·.expr)
    tgts.anyM fun t => do
      unless lhsAbs.expr == (← abstractMVars t.lhs).expr do return false
      unless rhsAbs.expr == (← abstractMVars t.rhs).expr do return false
      let tConds ← t.conds.mapM (AbstractMVarsResult.expr <$> abstractMVars ·.expr)
      return conds == tConds
  for rw in rws, idx in [:rws.size] do
    if ← contains keep    rw then pruned := pruned.push rw; continue
    if ← contains (← all) rw then pruned := pruned.push rw; continue
    keep := keep.push rw
    if let some stx := stx? then keepStx := keepStx.push stx[idx]!
  addPruned pruned
  return (keep, keepStx)

def generate' (cat : RewriteCategory) (g : GenM Premises) : GenM Unit := do
  let { rws := ⟨new, stxs⟩, facts } ← g
  addFacts facts
  let mut (new, stx) ← prune new (if stxs.isEmpty then none else stxs)
  if cat.isAutogenerated then
    let inv ← catchInvalidConditionals new (throw := false)
    new := new.filter fun n => !inv.any (n.src == ·.src)
    addPruned inv
    withTraceNode `egg.rewrites (fun _ => return m!"{cat.title} ({new.size})") do (Rewrites.trace new) #[] `egg.rewrites
  else
    withTraceNode `egg.rewrites (fun _ => return m!"{cat.title} ({new.size})") do new.trace stx `egg.rewrites
    _ ← catchInvalidConditionals new (throw := true)
  set cat new
  addAll new
where
  catchInvalidConditionals (rws : Rewrites) (throw : Bool) : MetaM Rewrites := do
    let mut remove := #[]
    let mut nextRw := false
    for rw in rws do
      nextRw := false
      for cond in rw.conds do
        if nextRw then break
        for m in cond.mvars.expr do
          unless rw.mvars.lhs.expr.contains m || rw.mvars.rhs.expr.contains m do
            if throw
            then throwError m!"egg: rewrite {rw.src} contains an unbound condition (expression)"
            else remove := remove.push rw; nextRw := true; break
        if nextRw then break
        for m in cond.mvars.lvl do
          unless rw.mvars.lhs.lvl.contains m || rw.mvars.rhs.lvl.contains m do
            if throw
            then throwError m!"egg: rewrite {rw.src} contains an unbound condition (level)"
            else remove := remove.push rw; nextRw := true; break
    return remove

def generate (cat : RewriteCategory) (g : GenM Rewrites) : GenM Unit := do
  generate' cat do return { rws.elems := ← g, rws.stxs := #[], facts := ⟨#[], #[]⟩ }

end GenM

def gen
    (goal : Congr) (ps : TSyntax `egg_premises) (guides : Guides) (cfg : Config)
    (amb : MVars.Ambient) : TacticM (Rewrites × Facts) := do
  withTraceNode `egg.rewrites (fun _ => return "Rewrites") do
    let { all, pruned, facts } ← GenM.run core
    traceFactsDefEqsPruned facts cfg pruned
    return (all, facts.elems)
where
  core : GenM Unit := open GenM in do
    generate' .basic     do Premises.elab { cfg with amb } ps
    generate  .tagged    do genTagged cfg amb
    generate  .builtins  do if cfg.builtins then Rewrites.builtins { cfg with amb } else pure #[]
    generate  .splits    do if cfg.genNestedSplits then genNestedSplits (← all) { cfg with amb } else pure #[]
    generate  .typeClass do genTcRws (← all) (← GenM.facts).elems
    generate  .explosion do if cfg.explosion then genExplosions (← all) else pure #[]

  -- TODO: This should also incorporate explosion and splitting in its fixed point.
  genTcRws (rws : Rewrites) (facts : Facts) : TacticM Rewrites := do
    let mut projTodo := #[]
    let mut specTodo := #[]
    let mut tcRws := #[]
    let mut covered : HashSet TcProj := ∅
    if cfg.genTcProjRws then projTodo := goal.tcProjTargets .goal ++ facts.tcProjTargets ++ guides.tcProjTargets ++ rws.tcProjTargets
    if cfg.genTcSpecRws then specTodo := rws
    while (cfg.genTcProjRws && !projTodo.isEmpty) || (cfg.genTcSpecRws && !specTodo.isEmpty) do
      if cfg.genTcProjRws then
        let (projRws, cov) ← genTcProjReductions projTodo covered { cfg with amb }
        projTodo := #[]
        covered  := cov
        specTodo := specTodo ++ projRws
        tcRws    := tcRws ++ projRws
      if cfg.genTcSpecRws then
        let goalType? ← do if cfg.genGoalTcSpec then pure <| some (← goal.type) else pure none
        let specRws ← genTcSpecializations specTodo cfg goalType?
        specTodo := #[]
        projTodo := specRws.tcProjTargets
        tcRws    := tcRws ++ specRws
    return tcRws

  traceFactsDefEqsPruned (facts : WithSyntax Facts) (cfg : Config.DefEq) (pruned : Rewrites) :
      TacticM Unit := do
    let cls := `egg.rewrites
    withTraceNode cls (fun _ => return m!"Hypotheses ({facts.elems.size})") do
      facts.elems.trace facts.stxs cls
    withTraceNode cls (fun _ => return "Definitional") do
      if cfg.beta             then Lean.trace cls fun _ => "β-Reduction"
      if cfg.eta              then Lean.trace cls fun _ => "η-Reduction"
      if cfg.etaExpand        then Lean.trace cls fun _ => "η-Expansion"
      if cfg.natLit           then Lean.trace cls fun _ => "Natural Number Literals"
      if cfg.levels           then Lean.trace cls fun _ => "Universe Levels"
      if cfg.eraseProofs      then Lean.trace cls fun _ => "Proof Irrelevance"
      if cfg.eraseTCInstances then Lean.trace cls fun _ => "Type Class Instances"
    withTraceNode cls (fun _ => return m!"Pruned ({pruned.size})") do pruned.trace #[] cls
